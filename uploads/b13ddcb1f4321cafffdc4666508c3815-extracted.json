{"title":"TreeCPP+Complete.pdf","contents":["#include <iostream>\n\n#include<stdio.h>\n\nusing namespace std;\n\nclass Node\n\n{\n\npublic:\n\n    Node *lchild;\n\n    int data;\n\n    Node *rchild;\n\n};\n\nclass Queue {\n\nprivate:\n\n    int front;\n\n    int rear;\n\n    int size;\n\n    Node **Q;\n\npublic:\n\n    Queue(){front=rear=-1;size=10;Q=new Node*[size];}\n\n    Queue(int size){front=rear=-1;this->size=size;;Q=new \nNode*[size];}\n\n    void enqueue(Node *x);\n\n    Node *dequeue();\n\n    int isEmpty(){ return front==rear;}\n\n};\n\nvoid Queue::enqueue(Node *x)\n\n{","Node *dequeue();\n\n    int isEmpty(){ return front==rear;}\n\n};\n\nvoid Queue::enqueue(Node *x)\n\n{\n\n    if(rear==size-1)\n\n        printf(\"Queue Full\\n\");\n\n    else\n\n    {\n\n        rear++;\n\n        Q[rear]=x;\n\n    }\n\n}\n\nNode *Queue::dequeue()\n\n{","Node *x=NULL;\n\n    if(front==rear)\n\n        printf(\"Queue is Empty\\n\");\n\n    else\n\n    {\n\n    \n\n    x=Q[front+1];\n\n    front++;\n\n    }\n\n    return x;\n\n}\n\nclass Tree\n\n{\n\n    Node *root;\n\npublic:\n\n    Tree(){root=NULL;}\n\n    void CreateTree();\n\n    void Preorder(){Preorder(root);}\n\n    void Preorder(Node *p);\n\n    void Postorder(){Postorder(root);}\n\n    void Postorder(Node *p);\n\n    void Inorder(){Inorder(root);}\n\n    void Inorder(Node *p);\n\n    void Levelorder(){Levelorder(root);}","void Inorder(Node *p);\n\n    void Levelorder(){Levelorder(root);}\n\n    void Levelorder(Node *p);\n\n    int Height(){return Height(root);}\n\n    int Height(Node *root);\n\n};\n\nvoid Tree::CreateTree()\n\n{\n\n    Node *p,*t=NULL;\n\n    int x;\n\n    Queue q(100);\n\n    printf(\"Eneter root value \");\n\n    scanf(\"%d\",&x);\n\n    root=new Node;\n\n    root->data=x;\n\n    root->lchild=root->rchild=NULL;","q.enqueue(root);\n\n    while(!q.isEmpty())\n\n    {\n\n        p=q.dequeue();\n\n        printf(\"eneter left child of %d \",p->data);\n\n        scanf(\"%d\",&x);\n\n        if(x!=-1)\n\n        {\n\n            t=new Node;\n\n            t->data=x;\n\n            t->lchild=t->rchild=NULL;\n\n            p->lchild=t;\n\n            q.enqueue(t);\n\n        }\n\n        printf(\"eneter right child of %d \",p->data);\n\n        scanf(\"%d\",&x);\n\n        if(x!=-1)\n\n        {\n\n            t=new Node;\n\n            t->data=x;","if(x!=-1)\n\n        {\n\n            t=new Node;\n\n            t->data=x;\n\n            t->lchild=t->rchild=NULL;\n\n            p->rchild=t;\n\n            q.enqueue(t);\n\n        }\n\n    }\n\n}\n\nvoid Tree::Preorder(struct Node *p)\n\n{\n\n    if(p)\n\n    {\n\n    \n\n    printf(\"%d \",p->data);\n\n    Preorder(p->lchild);\n\n    Preorder(p->rchild);\n\n    }\n\n}\n\nvoid Tree::Inorder(struct Node *p)","{\n\n    if(p)\n\n    {\n\n        \n\n            Inorder(p->lchild);\n\n            printf(\"%d \",p->data);\n\n            Inorder(p->rchild);\n\n    }\n\n}\n\nvoid Tree::Postorder(struct Node *p)\n\n{\n\n    if(p)\n\n    {\n\n        Postorder(p->lchild);\n\n        Postorder(p->rchild);\n\n        printf(\"%d \",p->data);\n\n    }\n\n}\n\n    void Tree::Levelorder(struct Node *p)\n\n    {\n\n        \n\n    Queue q(100);\n\n    printf(\"%d \",root->data);\n\n    q.enqueue(root);\n\n    while(!q.isEmpty())\n\n    {\n\n        root=q.dequeue();","q.enqueue(root);\n\n    while(!q.isEmpty())\n\n    {\n\n        root=q.dequeue();\n\n        if(root->lchild)\n\n        {\n\n            printf(\"%d \",root->lchild->data);\n\n            q.enqueue(root->lchild);\n\n        }\n\n        if(root->rchild)\n\n        {\n\n        }\n\n        printf(\"%d \",root->rchild->data);\n\n        q.enqueue(root->rchild);","}\n\n}\n\nint Tree::Height(struct Node *root)\n\n{\n\n    \n\n    int x=0,y=0;\n\n    if(root==0)\n\n        return 0;\n\n    x=Height(root->lchild); y=Height(root->rchild);\n\n    if(x>y)\n\n        return x+1;\n\n    else\n\n            return y+1;\n\n}\n\nint main() {\n\n    Tree t;\n\n    t.CreateTree();\n\n    cout<<\"Preorder \";\n\n    t.Preorder();\n\n    cout<<endl;\n\n    cout<<\"Inorder \";\n\n    t.Inorder();\n\n    cout<<endl<<endl;\n\n    return 0;\n\n}"]}