{"title":"142.+TreeCpp.pdf","contents":["Binary Tree Class\n#include <iostream>\n#include<stdio.h>\n#include \"QueueCpp.h\"\nusing namespace std;\nclass Tree\n{\n    Node *root;\n    \npublic:\n    Tree(){root=NULL;}\n    void CreateTree();\n    void Preorder(){Preorder(root);}\n    void Preorder(Node *p);\n    void Postorder(){Postorder(root);}\n    void Postorder(Node *p);\n    void Inorder(){Inorder(root);}\n    void Inorder(Node *p);\n    void Levelorder(){Levelorder(root);}\n    void Levelorder(Node *p);\n    int Height(){return Height(root);}","void Levelorder(Node *p);\n    int Height(){return Height(root);}\n    int Height(Node *root);\n};\nvoid Tree::CreateTree()\n{\n    Node *p,*t;\n    int x;\n    Queue q(100);\n    \n    printf(\"Eneter root value \");\n    scanf(\"%d\",&x);\n    root=new Node;\n    root->data=x;\n    root->lchild=root->rchild=NULL;\n    q.enqueue(root);","while(!q.isEmpty())\n    {\n        p=q.dequeue();\n        printf(\"eneter left child of %d \",p->data);\n        scanf(\"%d\",&x);\n        if(x!=-1)\n        {\n            t=new Node;\n            t->data=x;\n            t->lchild=t->rchild=NULL;\n            p->lchild=t;\n            q.enqueue(t);\n        }\n        printf(\"eneter right child of %d \",p->data);\n        scanf(\"%d\",&x);\n        if(x!=-1)\n        {\n            t=new Node;\n            t->data=x;\n            t->lchild=t->rchild=NULL;","{\n            t=new Node;\n            t->data=x;\n            t->lchild=t->rchild=NULL;\n            p->rchild=t;\n            q.enqueue(t);\n        }\n    }\n}\nvoid Tree::Preorder(struct Node *p)\n{\n    if(p)\n    {\n        printf(\"%d \",p->data);\n        Preorder(p->lchild);\n        Preorder(p->rchild);\n    }\n}\nvoid Tree::Inorder(struct Node *p)\n{\n    if(p)\n    {","Inorder(p->lchild);\n        printf(\"%d \",p->data);\n        Inorder(p->rchild);\n    }\n}\nvoid Tree::Postorder(struct Node *p)\n{\n    if(p)\n    {\n        Postorder(p->lchild);\n        Postorder(p->rchild);\n        printf(\"%d \",p->data);\n    }\n}\nvoid Tree::Levelorder(struct Node *root)\n{\n    Queue q(100);\n    \n    printf(\"%d \",root->data);\n    q.enqueue(root);\n    \n    while(!q.isEmpty())\n    {\n        root=q.dequeue();\n        if(root->lchild)\n        {","while(!q.isEmpty())\n    {\n        root=q.dequeue();\n        if(root->lchild)\n        {\n            printf(\"%d \",root->lchild->data);\n            q.enqueue(root->lchild);\n        }\n        if(root->rchild)\n        {\n            printf(\"%d \",root->rchild->data);\n            q.enqueue(root->rchild);\n        }\n    }\n}\nint Tree::Height(struct Node *root)\n{","int x=0,y=0;\n    if(root==0)\n        return 0;\n    x=Height(root->lchild);\n    y=Height(root->rchild);\n    if(x>y)\n        return x+1;\n    else\n        return y+1;\n    \n}\nint main()\n{\n    Tree t;\n    t.CreateTree();\n    cout<<\"Preorder \";\n    t.Preorder();\n    cout<<endl;\n    cout<<\"Inorder \";\n    t.Inorder();\n    cout<<endl<<endl;\n    \n    return 0;\n}"]}