{"title":"CN LAB USER MANUAL_merge.pdf","contents":["Department of Information Technology \nLAB MANUAL \nIT 1662 – COMPUTER NETWORKS LAB \n(B. Tech VI Semester) \n \n \n \n \n \n \nSikkim Manipal Institute of Technology \nMajitar, Rangpo, East Sikkim","Vision \nTo  become  a  front-runner  in  preparing  students  equipped  with  attributes  like  efficient  problem  solvers, \ninnovators, researchers and entrepreneurs, and in making them academia and industry ready.  \n \nMission \n To   offer   high-quality   undergraduate   program   namely Bachelor   of   Technology   in   Information \nTechnology  incorporating  latest  developments  in  the  area  of  Information  and  Communication","Technology into the curriculum, along with doctoral program. \n To  produce  competent  technocrats  and  researchers  in  order  to  meet  the  human  resource  needs  of \nindustries, government sectors, and the society as a whole. \n To offer a conducive academic environment to the students where creativity flourishes.  \n To teach students how to think in order to become an efficient problem solver. \n  \nProgram Specific Outcomes (PSO)","Program Specific Outcomes (PSO) \nPSO1: Students will be equipped with skills and competency to work and deliver quality results in industries, \nresearch organizations, and in the professional world as a whole. \nPSO2: Students will be competent to develop software solutions for different relevant problems in the world \nof   Information   and   Communication,   by   applying   knowledge   of   various   domains   such   as   Database","Technologies,  Information  Systems,  Network  Technologies,  Cloud  Technologies,  Algorithms,  Artificial \nIntelligence, Machine Learning, Cyber Security, Image Processing, and associated interdisciplinary subjects. \n \nProgram Educational Objectives (PEO) \n1. To improve the employability of students and prepare them for better employment.  \n2. To motivate students for higher education and research.","2. To motivate students for higher education and research.  \n3. To  encourage  students  for  becoming  future  entrepreneur  and  provide  them  an  ecosystem  for  the \nsame. \n4. To inculcate professional ethics in students and prepare them to become professionals driven by \nvalue  System.","Sikkim Manipal Institute of Technology \nSikkim Manipal University-737136 \nDepartment of Information Technology \n \nCERTIFICATE \n \nThis is to certify that Ms./Mr........................................................... \nReg. No.: ..................... Section: ...... Roll No.: .........has satisfactorily \ncompleted the lab exercises prescribed for COMPUTER NETWORKS LAB (IT 1662) \nof  Third  Year  B.Tech.  Degree  in  Information  Technology  at  SMIT,  in  the","of  Third  Year  B.Tech.  Degree  in  Information  Technology  at  SMIT,  in  the \nAcademic Year..................... \n \nDate: ....................................... \n \n \n \n \nSignature:           Signature: \nFaculty in Charge       Head of the Department","LIST OF PROGRAMS \nSr. \nNo. \nProgram Description Date Page \nNo. \nRemarks Signature \n1. a)  Write  a  program  to  create  a  child  process  and \nprint   the   process   ids   of   the   parent   and   child \nprocesses.  \nb)  Write  a  program  to  create  a  child  process  and \nsend a message from parent to child using PIPE.  \n \n    \n2 a)   Write   a   program,   to   demonstrate   two   way \ncommunications  between  parent  and  child  using \nPIPE.","communications  between  parent  and  child  using \nPIPE.  \nb)  Write  a  program,  to  create  an  orphan  process \nand print the process ids. \n \n    \n3. Write  a  reader  and  a  writer  program  to  send  the \nmessage   from   writer   to reader   using   message \nqueue \n. \n    \n4. Write a reader cum writer programs to demonstrate \ntwo way communications between them. \nWrite  a  reader  cum  writer  programs  to  send  a \nmessage   from   writer   to   reader   and   print   the \nfollowing:","message   from   writer   to   reader   and   print   the \nfollowing: \ni) Number of bytes in the queue.  \nii) Number of messages in the queue. \niii) PID of the last message sent. \niv) PID of the last message received. \n \n    \n5. Write  a  reader  and  a  writer  program  to  send  the \nmessage   from   writer   to   reader   using   shared \nmemory. \n    \n6. Write  a  client  program  and  server  program using \nTCP  socket  API  where  client  machine  will  send","TCP  socket  API  where  client  machine  will  send \nmessage  and  server  machine  will  receive  it.  [One-\nway communication] \n \n    \n7. Write  a  client  and  server  program  using  TCP \nsocket API to implement an echo server.  \n \n    \n8. Write a client program and a server program using \nTCP  socket  API  where  client  machine  will  send \nmessage and the server machine will receive it and \nvice versa. [Bidirectional communication]","vice versa. [Bidirectional communication] \n \n    \n9. Write  a  client  and  server  program  using  UDP \nsocket API to implement an echo server. \n \n    \n10. Write a client program and a server program using","UDP  socket  where  client  machine  will  send  a \nmessage  and  server  machine  will  receive  it.  [One \nway communication] \n \n11. Write a client program and a server program using \nUDP  socket  where  client machine  will  send  a \nmessage and the server machine will receive it and \nvice versa. [Bidirectional communication] \n \n    \n12. Write a client program and a server program using \nTCP/UDP  socket  API  where  client  machine  will \nsend  two  numbers  to  server  machine  and then","send  two  numbers  to  server  machine  and then \nserver  machine  will  perform  the  addition  of  two \nnumbers.  The  result  will  be  send  back  to  client \nmachine   by   the   server   machine.   [Bidirectional \ncommunication] \n \n    \n13. Write a client program and a server program using \nTCP/UDP  socket  API  where  client machine  will \nsend  any  string  to  server  machine  and  then  server \nmachine will send back the reverse of the string to","machine will send back the reverse of the string to \nclient machine. [Bidirectional communication] \n \n    \n14. Write a client program and a server program using \nTCP/UDP  socket  API  where  client machine  will \nask    for    any    mathematical    or    string    related \noperation   to   server   machine   and   the   server \nmachine  will  reply  to  client  machine  with  the \nsolution. [Bidirectional communication]","PROGRAM OUTCOMES (PO) \n \nPO 1 \nEngineering   knowledge:   Apply   the knowledge   of   mathematics,   science,   engineering \nfundamentals,  and  an  engineering  specialization  to  the  solution  of  complex  engineering \nproblems. \nPO 2 \nProblem  analysis:  Identify,  formulate,  review  research  literature,  and  analyze  complex \nengineering    problems    reaching    substantiated    conclusions    using    first    principles    of","mathematics, natural sciences, and engineering sciences. \nPO 3 \nDesign/development  of  solutions:  Design  solutions  for  complex  engineering  problems  and \ndesign  system  components  or  processes  that meet  the  specified  needs  with  appropriate \nconsideration  for  the  public  health  and  safety,  and  the  cultural,  societal,  and  environmental \nconsiderations. \nPO 4 \nConduct  investigations  of  complex  problems:  Use  research-based  knowledge  and  research","Conduct  investigations  of  complex  problems:  Use  research-based  knowledge  and  research \nmethods including design of experiments, analysis and interpretation of data, and synthesis of \nthe information to provide valid conclusions. \nPO 5 \nModern  tool  usage:  Create,  select,  and  apply  appropriate  techniques,  resources,  and  modern \nengineering and IT tools including prediction and modeling to complex engineering activities \nwith an understanding of the limitations. \nPO 6","with an understanding of the limitations. \nPO 6 \nThe  engineer  and  society:  Apply  reasoning  informed  by  the  contextual  knowledge  to  assess \nsocietal, health, safety, legal and cultural issues and the consequent responsibilities relevant to \nthe professional engineering practice. \nPO 7 \nEnvironment  and  sustainability:  Understand  the  impact  of  the  professional  engineering \nsolutions in societal and environmental contexts, and demonstrate the knowledge of, and need","solutions in societal and environmental contexts, and demonstrate the knowledge of, and need \nfor sustainable development. \nPO 8 \nEthics:  Apply  ethical  principles  and  commit  to  professional  ethics  and  responsibilities  and \nnorms of the engineering practice \nPO 9 \nIndividual and team work: Function effectively as an individual, and as a member or leader in \ndiverse teams, and in multidisciplinary settings. \nPO 10","diverse teams, and in multidisciplinary settings. \nPO 10 \nCommunication:   Communicate   effectively   on   complex   engineering   activities   with   the \nengineering  community  and  with  society  at  large,  such  as,  being  able  to  comprehend  and \nwrite effective reports and design documentation, make effective presentations, and give and \nreceive clear instructions. \nPO 11 \nProject   management   and   finance:   Demonstrate   knowledge   and   understanding   of   the","Project   management   and   finance:   Demonstrate   knowledge   and   understanding   of   the \nengineering and management principles and apply these to one’s own work, as a member and \nleader in a team, to manage projects and in multidisciplinary environments. \nPO 12 \nLife-long learning: Recognize the need for, and have the preparation and ability to engage in \nindependent and life-long learning in the broadest context of technological change.","Course Articulation Matrix (CAM) \n \n \n \nSUB. \nCODE \nSTATEMENT \nPO1 PO2 PO3 PO4 PO5 PO6 PO7 PO8 PO9 PO 10 PO 11 PO 12 PSO1 PSO2 \nCO1 \nTo get acquainted \nwith Linux /Unix \nsystem internals for \nInter Process \nCommunication. \n1 -  2 1 1 -  -  -  1 1 1 1 2 2 \nCO2 \nTo understand the \nconcept of Inter \nProcess \nCommunication and \nclient/server \narchitecture in \napplication \ndevelopment. \n1 -  3 2 3 -  -  -  2 1 1 1 2 3 \nCO3 \nTo understand how \nto use TCP and \nUDP based socket","1 -  3 2 3 -  -  -  2 1 1 1 2 3 \nCO3 \nTo understand how \nto use TCP and \nUDP based socket \nAPIs and their \ndifferences. \n1 2 3 2 3 -  -  -  2 1 1 1 2 3 \nCO4 \nTo design reliable \nservers applications \nusing both TCP and \nUDP sockets \n1 2 2 2 1 -  -  -  1 1 -  1 -  -  \n  \n \nIT1662 \n1.00 2.00 2.50 1.75         1.50 1.00 1.00 1.00 2.00 2.67 \n \nInternal Rubrics for Laboratory \n \n \nCO \n \nLAB NUMBERS CO1 CO2 CO3 CO4 \n \nLab 1+2 \n1 1 1 1 \n \nLab 3+4 \n1 1 1 1 \n \nLab 5+6 \n1 1 1 1 \n \nLab  7+8 \n1 1 1 1","Lab 1+2 \n1 1 1 1 \n \nLab 3+4 \n1 1 1 1 \n \nLab 5+6 \n1 1 1 1 \n \nLab  7+8 \n1 1 1 1 \n \nLab 9+10 \n1 1 1 1 \n \nLab 11+12 \n1 1 1 1","Course Objectives \n1. To get acquainted with Linux /Unix system internals for Inter Process Communication \n2. To write, execute and debug C programs based on IPC and Socket API.  \n3. To  understand  the  concept  of  Inter  Process  Communication  and  client/server  architecture  in \napplication development. \n4. To understand how to use TCP and UDP based socket APIs and their differences.  \n5. To design reliable server applications using both TCP and UDP sockets \n \nCourse Outcomes (CO):","5. To design reliable server applications using both TCP and UDP sockets \n \nCourse Outcomes (CO):  \nOn completion of this course students will be able - \nCO1: To get acquainted with Linux /Unix system internals for Inter Process Communication. \nCO2: To understand the concept of Inter Process Communication and client/server architecture in   \napplication development. \nCO3: To understand how to use TCP and UDP based socket APIs and their differences.","CO3: To understand how to use TCP and UDP based socket APIs and their differences. \nCO4: To design reliable server applications using both TCP and UDP sockets  \n \nEvaluation Plan \n Internal Assessment Marks: 60 Marks  \n Continuous  evaluation  component  (Program  Execution+  Lab  File+Viva)  for  each  experiment:10 \nmarks  \n The  assessment  will  depend  on  punctuality,  program  execution,  maintaining  the  observation  note \nand answering the questions in viva voce.","and answering the questions in viva voce. \n Total marks of 12 experiments (12 × 10) scaled down to 60. \n End semester assessment of 3-hour duration: 40 Marks \n At least 12 laboratory classes to be conducted. \n \nInternal Assessment(Continuous Lab Evaluation)    \nAlgorithm/flow \nchart/logic \ndiagram  \nImplementation  Output  Viva  File  Total \nmarks/ \nLab  \nTotal \nMarks  \n3 marks  3 marks  1 marks  2 marks  1 marks  10  60  \n120 marks  is scaled down to 60","Marks  \n3 marks  3 marks  1 marks  2 marks  1 marks  10  60  \n120 marks  is scaled down to 60  \n                                                      \nEnd Semester Assessment  \n40","Rubrics \nObjective  High \nProficiency \n(Marks)  \nMid \nProficiency \n(Marks)  \nLow \nProficiency \n(Marks)  \nNo \nProficiency \n(Marks)  \nAlgorithm/flow \nchart/logic \ndiagram  \n3  \n  \n2≤x<3  1≤x<2 0  \nImplementation  3  2≤x<3  1≤x<2 0  \nOutput  1  1≤x<0.5  0.5≤x<0 0  \nViva  2  2≤x<1 1 ≤x<0 0  \nFile  1  1≤x<0.5  0.5≤x<0 0","INSTRUCTIONS TO THE STUDENTS \nPre-Lab Session Instructions \n1. Students should carry the Lab Manual and the required stationery to every lab session. \n2. Be in time and follow the institution dress code. \n3. Must Sign in the log register. \n4. Make sure to occupy the allotted seat and mark the attendance.  \n5. Adhere to the rules and maintain the decorum. \nIn-Lab Session Instructions \n Follow the instructions on the allotted exercises.","In-Lab Session Instructions \n Follow the instructions on the allotted exercises. \n Show the program and results to the instructors on completion of experiments. \n On receiving approval from the instructor, copy the program and results in the Lab record. \n Prescribed textbooks and class notes can be kept ready for reference if required. \nGeneral Instructions for the exercises in Lab \n Implement the given exercise individually and not in a group."," Implement the given exercise individually and not in a group. \n The programs should meet the following criteria: \no Programs should be interactive with appropriate prompt messages, error messages if any, \nand descriptive messages for outputs. \no Programs  should  perform  input  validation  (Data  type,  range  error,  etc.)  and  five \nappropriate error messages and suggest corrective actions. \no Comments  should  be  used  to  give  the  statement  of  the  problem  and  every  member","o Comments  should  be  used  to  give  the  statement  of  the  problem  and  every  member \nfunction should indicate the purpose of the member function, inputs and outputs. \no Statements within the program should be properly indented. \no Use meaningful names for variables, classes, interfaces, packages and methods. \no Make use of constant and static members wherever needed. \n Plagiarism   (copy   from   others)   is   strictly   prohibited   and   would   invite   severe   penalty   in","evaluation. \n \n \n The exercises for each week are divided under three sets: \no Solved exercise \no Lab exercises- to be completed during lab hours \no Additional Exercises – to be completed outside the lab or in the lab to enhance the skill. \n In case a student misses a lab class, he/she must ensure that the experiment is completed during \nthe repetition class with the permission of the faculty concerned but credit will be given only to \none day’s experiment(s).","one day’s experiment(s). \n Questions  for  lab  tests  and  examination  are  not  necessarily  limited  to  the  questions  in  the \nmanual, but may involve some variations and/or combinations of the questions.","The students should not \n Bring mobile phones or any other electronic gadgets to the lab. \n Go out of the lab without permission. \n \nText Book: \n1. Unix Network Programming, W. Richard Stevens, PHI \n \nReference Books: \n1. Unix  Network  Programming,  Volume  1:  The  Sockets  Networking API,  W.  Stevens,  Bill  Fenner,  Andrew \nRudoff \n2. UNIX Network Programming, Volume2: The Inter Process Communication, W. Richard Stevens.","Sample Example Programs: \n \nInter Process Communication: \n \nProg #1. Write a program to create a parent and child process using the system call fork(). \n \nThe fork () System Call \n \nSystem call fork() is used to create processes. It takes no arguments and returns a process ID. The \npurpose of fork() is to create a new process, which becomes the child process of the caller. After a \nnew child process is   created, both processes   will   execute   the   next   instruction   following","the fork() system call. Therefore, we have to distinguish the parent from the child. This can be done \nby testing the  returned  value  of  fork(): If  fork()  returns  a  negative  value,  the  creation  of  a  child \nprocess  was  unsuccessful. fork() returns  a zero  to the newly created child  process. fork()  returns  a \npositive value, the process ID of the child process, to the parent. The returned process ID is of type","pid_t  defined  in  sys/types.h.  Normally,  the  process  ID  is  an  integer.  Moreover, a process can  use \nfunction  getpid() to  retrieve the process ID assigned to this  process. Therefore, after the system \ncall to fork(), a simple test can tell which process is the child. Please note that Unix will make an \nexact  copy  of  the  parent's  address  space  and  give  it  to  the  child. Therefore, the  parent and child \nprocesses have separate address spaces.","processes have separate address spaces. \n \nLet us take an example to make the above points clear. This example does not distinguish parent \nand the child processes. \n \n#include <stdio.h> \n#include <string.h> \n#include <sys/types.h> \n \n#define MAX_COUNT 200 \n#define BUF_SIZE 100 \n \nvoid main(void) \n{ \npid_t pid; \nint i; \nchar buf[BUF_SIZE]; \n \nfork(); \npid = getpid(); \nfor (i = 1; i <= MAX_COUNT; i++) { \nsprintf(buf, \"This line is from pid %d, value = %d\\n\", pid, i);","write(1, buf, strlen(buf)); \n} \n} \nSuppose the above program executes up to the point of the call to fork() (marked in red color): \n \nIf the call to fork() is executed successfully, Unix will \nmake two identical copies of address spaces, one for the parent and the other for the child. \nBoth processes will start their execution at the next statement following the fork() call. In this case, \nboth processes will start their execution at the assignment statement as shown below:","both processes will start their execution at the assignment statement as shown below: \n \nBoth  processes  start  their  execution  right  after  the  system  call  fork().  Since  both  processes  have \nidentical but separate address spaces, those variables initialized before the fork() call have the same \nvalues in both address spaces. Since every process has its own address space, any modifications","values in both address spaces. Since every process has its own address space, any modifications \nwill be independent of the others. In other words, if the parent changes the value of its variable, the \nmodification will only affect the variable in the parent process's address space. Other address spaces \ncreated by fork() calls will not be affected even though they have identical variable names.What is","the reason of using  write  rather than  printf? It is because  printf()  is \"buffered,\" meaning \nprintf()  will  group  the  output  of  a  process  together.  While  buffering  the  output  for  the parent \nprocess, the child may also use printf to print out some information, which will also be buffered. As \na result, since the output will not be send to screen immediately, you may not get the","right order of the expected result. Worse, the output from the two processes may be mixed in \nstrange ways. To overcome this problem, you may consider to use the \"unbuffered\" write. \nIf you run this program, you might see the following on the screen: \n................ \nThis line is from pid 3456, value 13 \nThis line is from pid 3456, value 14 \n................ \nThis line is from pid 3456, value 20 \nThis line is from pid 4617, value 100 \nThis line is from pid 4617, value 101 \n................","This line is from pid 4617, value 100 \nThis line is from pid 4617, value 101 \n................ \nThis line is from pid 3456, value 21 \nThis line is from pid 3456, value 22 \n................ \nProcess  ID  3456  may  be  the  one  assigned  to  the parent  or  the  child.  Due  to  the  fact  that  these \nprocesses  are  run  concurrently,  their  output  lines  are  intermixed  in  a  rather  unpredictable  way.","Moreover,  the  order  of  these  lines  are  determined  by  the  CPU  scheduler.  Hence,  if  you  run  this \nprogram again, you may get a totally different result. \n \nProg #2. Write a program, which distinguishes the parent process from the child process. \n \n#include <stdio.h> \n#include <sys/types.h> \n \n#define MAX_COUNT 200 \n \nvoid ChildProcess(void); /* child process prototype */ \nvoid ParentProcess(void); /* parent process prototype */ \n \nvoid main(void) \n{ \npid_t pid; \n \npid = fork();","void main(void) \n{ \npid_t pid; \n \npid = fork(); \nif (pid == 0) \nChildProcess(); \nelse \nParentProcess(); \n} \n \nvoid ChildProcess(void) \n{ \nint i; \n \nfor (i = 1; i <= MAX_COUNT; i++) \nprintf(\" This line is from child, value = %d\\n\", i); \nprintf(\" *** Child process is done ***\\n\"); \n}","void ParentProcess(void) \n{ \nint i; \n \nfor (i = 1; i <= MAX_COUNT; i++) \nprintf(\"This line is from parent, value = %d\\n\", i); \nprintf(\"*** Parent is done ***\\n\"); \n} \nIn this program, both processes print lines that indicate (1) whether the line is printed by the child \nor by the parent  process, and  (2)  the value  of variable i.  For simplicity, printf()  is  used. When  the \nmain program executes fork(), an identical copy of its address space, including the program and all","data,  is  created.  System  call  fork()  returns  the  child  process  ID  to  the  parent  and returns  0  to  the \nchild  process.  The  following  figure  shows  that  in  both  address  spaces  there  is  a variable  pid.  The \none in the parent receives the child's process ID 3456 and the one in the child receives 0. \n \nNow both programs (i.e., the parent and child) will execute independent of each other starting at the \nnext statement:","In the parent, since pid is non-zero, it calls function ParentProcess(). On the other hand, the child \nhas a zero pid and calls ChildProcess() as shown below: \n \nDue to the fact that the CPU scheduler will assign a time quantum to each process, the parent or the \nchild  process  will  run  for  some  time  before  the  control  is  switched  to  the  other  and  the  running \nprocess will print some lines before you can see any line printed by the other process. Therefore,","process will print some lines before you can see any line printed by the other process. Therefore, \nthe value of MAX_COUNT should be large enough so that both processes will run for at least two \nor more time quanta. If the value of MAX_COUNT is so small that a process can finish in one time \nquantum,  you  will  see  two  groups  of  lines,  each  of  which  contains  all  lines  printed  by  the  same \nprocess.","Prog #3. Write a program, to demonstrate how pipes are used in Linux Processes \nUsing Pipes in Linux Processes \nPipes  can  be  used in  threads  and processes. The  program below  demonstrates  how pipes  can  be \nused in processes. A new process can be created using the system call fork(). It returns two differnt \nvalues  to  the  child  and  parent.  The  value  0  is  returned  to  the  child  (new)  process  and  the  PID","(Process  ID)  of  the  child  is  returned  to  the  parent  process.  This  is  used  to  distinguish  between  the \ntwo processes.  In the program  given below, the  child process waits for the user input and once an \ninput is entered, it writes into the pipe. And the parent process reads from the pipe. \n \nA sample program to demonstrate how pipes are used in Linux Processes \n#include <stdio.h> \n#include <sys/types.h> \n#include <unistd.h> \n#include <stdlib.h> \n#include <string.h>","#include <sys/types.h> \n#include <unistd.h> \n#include <stdlib.h> \n#include <string.h> \n#define MSGLEN 64 \nint main(){ \nint fd[2]; \npid_t pid; \nint result; \n \n//Creating a pipe \nresult = pipe (fd); \nif (result < 0) { \n//failure in creating a pipe \nperror(\"pipe\"); \nexit (1); \n} \n \n//Creating a child process \npid = fork(); \nif (pid < 0) { \n//failure in creating a child \nperror (\"fork\"); \nexit(2); \n} \n \nif (pid == 0) { \n//Child process \nchar message[MSGLEN]; \nwhile(1) {","//Clearing the message \nmemset (message, 0, sizeof(message)); \nprintf (\"Enter a message: \"); \nscanf (\"%s\",message); \n \n//Writing message to the pipe \nwrite(fd[1], message, strlen(message)); \n} \nexit (0); \n} \nelse { \n//Parent Process \nchar message[MSGLEN]; \n \nwhile (1) { \n//Clearing the message buffer \nmemset (message, 0, sizeof(message)); \n \n//Reading message from the pipe \nread (fd[0], message, sizeof(message)); \nprintf(\"Message entered %s\\n\",message); \n} \n \nexit(0); \n} \n}","printf(\"Message entered %s\\n\",message); \n} \n \nexit(0); \n} \n} \n \nPipes are one of the most commonly used mechanisms for IPC (inter process communication). IPC \nis  the  mechanism  by  which  two  or  more  processes  communicate  with  each  other.  The  commonly \nused  IPC  techniques  include  shared  memory,  message  queues,  pipes  and  FIFOs  (and  sometimes \neven files). Pipes are helpful in the unidirectional form of communication between processes. The \npipe() creates a pipe.","pipe() creates a pipe. \n \nSyntax: \n \nint pipe(fd[2]) \n \npipe()  creates  a  pair  of  file  descriptors,  pointing  to  a  pipe  inode,  and  places  them  in  the  array \npointed  to  by  fd.  fd[0] is for reading, fd[1] is for writing. Let’s see a simple program how to use \npiping. \n \n#include <unistd.h> \n#include <stdlib.h> \n#include <stdio.h> \n#include <string.h> \n \n#define MSG_LEN 64","int main(){ \n \nint result; \nint fd[2]; \nchar *message=\"Linux World!!!\"; \nchar recvd_msg[MSG_LEN]; \nresult = pipe (fd); //Creating a pipe fd[0] is for reading and fd[1] is for writing \nif (result < 0) { \nperror(\"pipe \"); \nexit(1); \n} \n \n//writing the message into the pipe \n \nresult=write(fd[1],message,strlen(message)); \nif (result < 0) { \nperror(\"write\"); \nexit(2); \n} \n//Reading the message from the pipe \nresult=read (fd[0],recvd_msg,MSG_LEN); \nif (result < 0) { \nperror(\"read\"); \nexit(3); \n}","result=read (fd[0],recvd_msg,MSG_LEN); \nif (result < 0) { \nperror(\"read\"); \nexit(3); \n} \n \nprintf(\"%s\\n\",recvd_msg); \nreturn 0; \n} \nAs seen above , the pipe() system call creates a pipe. Now normal system calls like read() or write() \ncan be used for reading and writing data to the pipe. As you have noticed the fd[0] can only be used \nfor reading from the pipe and does not permit writing. Similarly fd[1] can only be used to perform","for reading from the pipe and does not permit writing. Similarly fd[1] can only be used to perform \nwriting to the pipe. You are writing into the pipe and reading from it. That one can do even from a \nfile. Now let’s see another scenario. If we add more writes in the above program before reading \nanything and then start reading,  you will find that the first read call will fetch  you the first written","message and so on. So pipe() is helpful in Implementing a QUEUE strategy(First in First out) FIFO: \nthe  message  which  was  written  first  will  be  available  for  the  first  read,  then  the  message which \ncame second, for the second read.","Note: The first read itself can get all of the messages written by different write, if it specifies a large \nsize in the size field (a size which can span the size of one or more writes ) as demonstrated here \n \n#include <unistd.h> \n#include <stdlib.h> \n#include <stdio.h> \n#include <string.h> \n#define MSG_LEN 64 \nint main(){ \nint result; \nint fd[2]; \nchar message[MSG_LEN]; \nchar recvd_msg[MSG_LEN]; \nresult = pipe (fd); //Creating a pipe//fd[0] is for reading and fd[1] is for writing","result = pipe (fd); //Creating a pipe//fd[0] is for reading and fd[1] is for writing \nif (result < 0) { \nperror(\"pipe \"); \nexit(1); \n} \nstrncpy(message,\"Linux World!! \",MSG_LEN); \nresult=write(fd[1],message,strlen(message)); \nif (result < 0) { \nperror(\"write\"); \nexit(2); \n} \nstrncpy(message,\"Understanding \",MSG_LEN); \n \nresult=write(fd[1],message,strlen(message)); \nif (result < 0) { \nperror(\"write\"); \nexit(2); \n} \n \nstrncpy(message,\"Concepts of \",MSG_LEN);","if (result < 0) { \nperror(\"write\"); \nexit(2); \n} \n \nstrncpy(message,\"Concepts of \",MSG_LEN); \n \nresult=write(fd[1],message,strlen(message)); \nif (result < 0) { \nperror(\"write\"); \nexit(2); \n} \n \nstrncpy(message,\"Piping \", MSG_LEN);","result=write(fd[1],message,strlen(message)); \n \nif (result < 0) { \nperror(\"write\"); \nexit(2); \n} \n \nresult=read (fd[0],recvd_msg,MSG_LEN); \nif (result < 0) { \nperror(\"read\"); \nexit(3); \n} \n \nprintf(\"%s\\n\",recvd_msg); \nreturn 0; \n \n} \n \n. \nProg #4. Write a program, to implement message queue and demonstrate it. \n \nIPC Message Queue Implementation in C \n \nA simple  implementation of IPC Message Queues \nIPC_msgq_send.c   adds   the   message   on   the   message    queue    IPC_msgq_rcv.c removes","IPC_msgq_send.c   adds   the   message   on   the   message    queue    IPC_msgq_rcv.c removes \nthe message from the message queue. \n \nTo  use  this  program  first  compile  and  run  IPC_msgq_send.c  to  add  a  message  to  the message \nqueue. To see the Message Queue type ipcs -q on your Unix/Linux Terminal. \n \n \nNow compile and run IPC_msgq_rcv.c to read the message from the Message Queue. To see \nthat you have read the message again use ipcs -q \n \n//IPC_msgq_send.c","that you have read the message again use ipcs -q \n \n//IPC_msgq_send.c \n \n#include <sys/types.h> \n#include <sys/ipc.h> \n#include <sys/msg.h> \n#include <stdio.h>","#include <string.h> \n#include <stdlib.h> \n#define MAXSIZE 128 \nvoid die(char *s) \n{ \nperror(s); \nexit(1); \n} \nstruct msgbuf \n{ \nlong mtype; \nchar mtext[MAXSIZE]; \n}; \n \nmain() \n{ \nint msqid; \nint msgflg = IPC_CREAT | 0666; \nkey_t key; \nstruct msgbuf sbuf; \nsize_t buflen; \n \nkey = 1234; \n \nif ((msqid = msgget(key, msgflg )) < 0) //Get the message \nqueue ID for the given key \ndie(\"msgget\"); \n \n//Message Type \nsbuf.mtype = 1; \n \nprintf(\"Enter a message to add to message queue : \");","//Message Type \nsbuf.mtype = 1; \n \nprintf(\"Enter a message to add to message queue : \"); \nscanf(\"%[^\\n]\",sbuf.mtext); \ngetchar(); \n \nbuflen = strlen(sbuf.mtext) + 1 ; \n \nif (msgsnd(msqid, &sbuf, buflen, IPC_NOWAIT) < 0) \n{ \n \nbuflen); \n \n} \nprintf (\"%d, %d, %s, %d\\n\", msqid, sbuf.mtype, sbuf.mtext, \ndie(\"msgsnd\"); \n \nelse","printf(\"Message Sent\\n\"); \n \nexit(0); \n} \n \n \n//IPC_msgq_rcv.c \n#include <sys/types.h> \n#include <sys/ipc.h> \n#include <sys/msg.h> \n#include <stdio.h> \n#include <stdlib.h> \n#define MAXSIZE 128 \nvoid die(char *s) \n{ \nperror(s); \nexit(1); \n} \ntypedef struct msgbuf \n{ \nlong mtype; \nchar mtext[MAXSIZE]; \n} ; \n \n \nmain() \n{ \nint msqid; \nkey_t key; \nstruct msgbuf rcvbuffer; \nkey = 1234; \nif ((msqid = msgget(key, 0666)) < 0) \ndie(\"msgget()\"); \n \n \n//Receive an answer of message type 1.","if ((msqid = msgget(key, 0666)) < 0) \ndie(\"msgget()\"); \n \n \n//Receive an answer of message type 1. \nif (msgrcv(msqid, &rcvbuffer, MAXSIZE, 1, 0) < 0) \ndie(\"msgrcv\"); \n \nprintf(\"%s\\n\", rcvbuffer.mtext); \nexit(0) \n}","Socket Programming:  \n \nHow do we build Internet applications? In this lecture, we will discuss the socket API and support \nfor  TCP  and  UDP  communications  between  end  hosts.  Socket  programing  is  the  key  API  for \nprogramming distributed applications on the Internet. \n \nBTW, Kurose/Ross only cover Java socket programming and not C socket programming discussed \nbelow. \n \n \n \nThe  scenario of  the client  and  the server  on the same  local  network (usually  called LAN, Local","Area Network) is shown in Figure \n \n \n \n \nClient and server on the same Ethernet communicating using TCP/IP.","The  client  and  the  server  may  be  in  different  LANs,  with  both  LANs  connected  to  a  Wide  Area \nNetwork  (WAN)  by  means  of routers.  The  largest  WAN  is  the  Internet,  but  companies  may  have \ntheir own WANs. This scenario is depicted in Figure 2. \n \n \n \n \nClient and server on different LANs connected through WAN/Internet. \n \n \nThe flow of information between the client and the server goes down the protocol stack on one side,","then across the network and then up the protocol stack on the other side. \n \nUser Datagram Protocol (UDP) \n \nUDP is a simple transport-layer protocol. The application writes a message to a UDP socket, which \nis then encapsulated in a UDP datagram, which is further encapsulated in an IP datagram, which is \nsent to the destination. \n \nThere is no guarantee that a UDP will reach the destination, that the order of the datagrams will be","preserved across the network or that datagrams arrive only once. \n \nThe  problem  of  UDP  is  its  lack  of  reliability:  if  a  datagram  reaches  its  final  destination  but  the \nchecksum  detects  an  error,  or  if  the  datagram  is  dropped  in  the  network,  it  is  not  automatically \nretransmitted.","Each UDP datagram is characterized by  a  length. The  length of  a  datagram is passed  to the \nreceiving application along with the data. \n \nNo connection is established between the client and the server and, for this reason, we say that UDP \nprovides a connection-less service. \n \nIt is described in RFC 768. \n \nTransmission Control Protocol (TCP) \n \nTCP  provides  a connection  oriented  service,  since  it  is  based  on  connections  between  clients  and \nservers.","servers. \n \nTCP provides reliability. When a TCP client send data to the server, it requires an \nacknowledgement  in  return.  If  an  acknowledgement  is  not  received,  TCP  automatically  retransmit \nthe data and waits for a longer period of time. \n \nWe have mentioned that UDP datagrams are characterized by a length. TCP is instead a byte-stream \nprotocol, without any boundaries at all. \n \nTCP is described in RFC 793, RFC 1323, RFC 2581 and RFC 3390. \n \nSocket addresses","TCP is described in RFC 793, RFC 1323, RFC 2581 and RFC 3390. \n \nSocket addresses \n \nIPv4 socket  address  structure   is   named sockaddr_in and   is    defined   by   including \nthe <netinet/in.h> header. \n \nThe POSIX definition is the following: \n \n \nstruct in_addr{ \nin_addr_t s_addr; /*32 bit IPv4 network byte ordered address*/ \n}; \n \n \nstruct sockaddr_in { \nuint8_t sin_len; /* length of structure (16)*/ \nsa_family_t sin_family; /* AF_INET*/","uint8_t sin_len; /* length of structure (16)*/ \nsa_family_t sin_family; /* AF_INET*/ \nin_port_t sin_port; /* 16 bit TCP or UDP port number */ \nstruct in_addr sin_addr; /* 32 bit IPv4 address*/ \nchar sin_zero[8]; /* not used but always set to zero */ \n}; \n \nThe uint8_t datatype is unsigned 8-bit integer.","Generic Socket Address Structure \n \nA  socket  address  structure  is always  passed  by  reference  as  an  argument  to  any  socket  functions. \nBut  any  socket  function  that  takes  one  of  these  pointers  as  an  argument  must  deal  with  socket \naddress structures from any of the supported protocol families. \n \nA problem arises in declaring the type of pointer that is passed. With ANSI C, the solution is to","A problem arises in declaring the type of pointer that is passed. With ANSI C, the solution is to \nuse void * (the generic pointer type). But the socket functions predate the definition of ANSI C \nand the solution chosen was to define a generic socket address as follows: \n \n \nstruct sockaddr { \nuint8_t sa_len; \nsa_family_t sa_family; /* address family: AD_xxx value */ \nchar sa_data[14]; \n}; \n \nHost Byte Order and Network Byte Order Conversion","char sa_data[14]; \n}; \n \nHost Byte Order and Network Byte Order Conversion \n \nThere are two ways to store two bytes in memory: with the lower-order byte at the starting address \n(little-endian byte order) or with the high-order byte at the starting address (big-endian byte order). \nWe call them collectively host byte order. For example, an Intel processor stores the 32-bit integer \nas four consecutives bytes in memory in the order 1-2-3-4, where 1 is the most significant byte.","as four consecutives bytes in memory in the order 1-2-3-4, where 1 is the most significant byte. \nIBM PowerPC processors would store the integer in the byte order 4-3-2-1. \n \nNetworking protocols such as TCP are based on a specific network byte order. The Internet \nprotocols use big-endian byte ordering. \n \nThe htons(), htonl(), ntohs(), and ntohl() Functions \n \nThe follwowing functions are used for the conversion: \n \n \n#include <netinet/in.h> \n \nuint16_t htons(uint16_t host16bitvalue);","#include <netinet/in.h> \n \nuint16_t htons(uint16_t host16bitvalue); \nuint32_t htonl(uint32_t host32bitvalue); \nuint16_t ntohs(uint16_t net16bitvalue); \nuint32_t ntohl(uint32_t net32bitvalue); \nThe first two return the value in network byte order (16 and 32 bit, respectively). The latter return \nthe value in host byte order (16 and 32 bit, respectively).","TCP Socket API \n \nThe sequence of function calls for the client and a server participating in a TCP connection is \npresented in Figure \n \n \n \nTCP client-server.","As shown in the figure, the steps for establishing a TCP socket on the client side are the following: \n \n Create a socket using the socket() function; \n Connect the socket to the address of the server using the connect() function; \n Send and receive data by means of the read() and write() functions. \n Close the connection by means of the close() function. \n \nThe steps involved in establishing a TCP socket on the server side are as follows:","The steps involved in establishing a TCP socket on the server side are as follows: \n \n Create a socket with the socket() function; \n Bind the socket to an address using the bind() function; \n Listen for connections with the listen() function; \n Accept a connection with the accept() function system call. This call typically blocks \nuntil a client connects with the server. \n Send and receive data by means of send() and receive(). \n Close the connection by means of the close() function."," Close the connection by means of the close() function. \n \nThe socket() Function \n \nThe first step is to call the socket function, specifying the type of communication protocol (TCP \nbased on IPv4, TCP based on IPv6, UDP). \n \nThe function is defined as follows: \n \n \n#include <sys/socket.h> \n \nint socket (int family, int type, int protocol); \n \nwhere family specifies the protocol family (AF_INET for the IPv4 protocols), type is a","where family specifies the protocol family (AF_INET for the IPv4 protocols), type is a \nconstant described the type of socket (SOCK_STREAM for stream sockets and SOCK_DGRAM for \ndatagram sockets. \n \nThe function returns a non-negative integer number, similar to a file descriptor, that we \ndefine socket descriptor or -1 on error. \n \nThe connect() Function \n \nThe connect() function is used by a TCP client to establish a connection with a TCP server/ \nThe function is defined as follows:","#include <sys/socket.h> \n \nint connect (int sockfd, const struct sockaddr *servaddr, socklen_ \nt addrlen); \n \nwhere sockfd is the socket descriptor returned by the socket function. \n \nThe function returns 0 if the it succeeds in establishing a connection (i.e., successful TCP three-way \nhandshake, -1 otherwise. \n \nThe  client  does not  have  to  call bind() in  Section  before  calling  this  function:  the  kernel  will \nchoose both an ephemeral port and the source IP if necessary.","choose both an ephemeral port and the source IP if necessary. \n \nThe bind() Function \n \nThe bind() assigns a local protocol address to a socket. With the Internet protocols, the address is \nthe combination of an IPv4 or IPv6 address (32-bit or 128-bit) address along with a 16 bit TCP port \nnumber. \n \nThe function is defined as follows: \n \n \n#include <sys/socket.h> \n \nint bind(int sockfd, const struct sockaddr *servaddr, socklen_t ad \ndrlen);","int bind(int sockfd, const struct sockaddr *servaddr, socklen_t ad \ndrlen); \n \nwhere sockfd is the socket descriptor, servaddr is a pointer to a protocol-specific address \nand addrlen is the size of the address structure. \n \nbind() returns 0 if it succeeds, -1 on error. \n \nThis  use  of the  generic socket  address sockaddr requires  that  any  calls  to  these  functions  must \ncast the pointer to the protocol-specific address structure. For example for and IPv4 socket \nstructure:","structure: \n \n \nstruct sockaddr_in serv; /* IPv4 socket address structure */ \nbind(sockfd, (struct sockaddr*) &serv, sizeof(serv)) \nA  process  can  bind  a  specific  IP  address  to  its  socket:  for  a  TCP  client,  this  assigns  the  source  IP \naddress  that  will  be  used  for  IP  datagrams  sent  on  the  sockets.  For  a  TCP  server,  this  restricts  the \nsocket to receive incoming client connections destined only to that IP address.","Normally, a TCP client does not bind an IP address to its socket. The kernel chooses the source IP \nsocket is connected, based on the outgoing interface that is used. If a TCP server does not bind an \nIP  address  to  its  socket,  the  kernel  uses  the  destination  IP  address  of  the  incoming  packets  as  the \nserver’s source address. \n \nbind() allows to specify the IP address, the port, both or neither. \nThe table below summarizes the combinations for IPv4. \n \nIP Address IP Port Result","The table below summarizes the combinations for IPv4. \n \nIP Address IP Port Result \nINADDR_ANY \n0 Kernel chooses IP address and port \nINADDR_ANY \nnon zero Kernel chooses IP address, process specifies port \nLocal IP address 0 Process specifies IP address, kernel chooses port \nLocal IP address non zero Process specifies IP address and port \n \nNote,  the  local  host  address  is  127.0.0.1;  for  example,  if  you  wanted  to  run  your  echoServer  (see","later) on your local machine the your client would connect to 127.0.0.1 with the suitable port. \n \nThe listen() Function \n \nThe listen() function converts an unconnected socket into a passive socket, indicating that the \nkernel should accept incoming connection requests directed to this socket. It is defined as follows: \n \n \n#include <sys/socket.h> \n \nint listen(int sockfd, int backlog); \n \nwhere sockfd is the socket descriptor and backlog is the maximum number of connections the","where sockfd is the socket descriptor and backlog is the maximum number of connections the \nkernel should queue for this socket. The backlog argument provides an hint to the system of the \nnumber  of  outstanding  connect  requests  that  it  should  enqueue  on  behalf  of  the  process.  Once  the \nqueue  is  full,  the  system will  reject  additional  connection  requests.  The backlog value  must  be \nchosen based on the expected load of the server.","chosen based on the expected load of the server. \n \nThe function listen() return 0 if it succeeds, -1 on error. \n \nThe accept() Function \n \nThe accept() is used to retrieve a connect request and convert that into a request. It is defined as \nfollows: \n \n \n#include <sys/socket.h> \n \nint accept(int sockfd, struct sockaddr *cliaddr, \nsocklen_t *addrlen);","where sockfd is a new file descriptor that is connected to the client that called the connect(). \nThe cliaddr and addrlen arguments are used to return the protocol address of the client. The \nnew  socket  descriptor  has  the  same  socket  type  and  address  family  of  the  original  socket.  The \noriginal  socket  passed to accept() is  not  associated  with  the  connection,  but  instead  remains","available  to  receive  additional  connect  requests.  The  kernel  creates  one  connected  socket  for  each \nclient connection that is accepted. \n \nIf we don’t care about the client’s identity, we can set the cliaddr and addrlen to NULL. \nOtherwise, before calling the accept function, the cliaddr parameter has to be set to a buffer \nlarge enough to hold the address and set the interger pointed by addrlen to the size of the buffer. \n \nThe send() Function","The send() Function \n \nSince a socket endpoint is represented as a file descriptor, we can use read and write to \ncommunicate  with  a  socket  as  long  as  it  is  connected.  However,  if  we  want  to  specify  options  we \nneed another set of functions. \n \nFor example, send() is similar to write() but allows to specify some options. send() is \ndefined as follows: \n \n \n#include <sys/socket.h> \nssize_t send(int sockfd, const void *buf, size_t nbytes, int flags \n);","#include <sys/socket.h> \nssize_t send(int sockfd, const void *buf, size_t nbytes, int flags \n); \n \nwhere buf and nbytes have the same meaning as they have with write. The additional \nargument flags is used to specify how we want the data to be transmitted. We will not consider \nthe possible options in this course. We will assume it equal to 0. \n \nThe function returns the number of bytes if it succeeds, -1 on error. \n \nThe receive() Function","The function returns the number of bytes if it succeeds, -1 on error. \n \nThe receive() Function \n \nThe recv() function is similar to read(), but allows to specify some options to control how the \ndata are received. We will not consider the possible options in this course. We will assume it equal \nto 0. \n \nreceive is defined as follows: \n \n#include <sys/socket.h> \nssize_t recv(int sockfd, void *buf, size_t nbytes, int flags);","#include <sys/socket.h> \nssize_t recv(int sockfd, void *buf, size_t nbytes, int flags); \n \nThe function returns the length of the message in bytes, 0 if no messages are available and peer had \ndone an orderly shutdown, or -1 on error.","The close() Function \n \nThe normal close() function is used to close a socket and terminate a TCP socket. It returns 0 if \nit succeeds, -1 on error. It is defined as follows: \n \n \n#include <unistd.h> \nint close(int sockfd); \nUDP Socket API \nThere are some fundamental differences between TCP and UDP sockets. UDP is a connection-less, \nunreliable,  datagram protocol (TCP is instead connection-oriented,  reliable  and stream based).","unreliable,  datagram protocol (TCP is instead connection-oriented,  reliable  and stream based). \nThere  are  some  instances  when  it  makes  to  use  UDP  instead  of  TCP.  Some  popular  applications \nbuilt  around  UDP  are  DNS,  NFS,  SNMP  and  for  example,  some  Skype  services  and  streaming \nmedia. \n \nFigure 4 shows the the interaction between a UDP client and server. First of all, the client does not","establish a connection with the server.  Instead, the client just sends a datagram to the server using \nthe sendto function  which requires  the  address  of  the  destination  as  a  parameter.  Similarly,  the \nserver   does   not   accept    a   connection    from    a   client.    Instead,    the   server   just    calls \nthe recvfromfunction, which waits until data arrives from some client. recvfrom returns the IP","the recvfromfunction, which waits until data arrives from some client. recvfrom returns the IP \naddress of the client, along with the datagram, so the server can send a response to the client. \n \nAs  shown  in  the  Figure, the  steps  of  establishing  a  UDP  socket  communication  on  the  client side \nare as follows: \n \n Create a socket using the socket() function; \n Send and receive data by means of the recvfrom() and sendto() functions."," Send and receive data by means of the recvfrom() and sendto() functions. \n \nThe steps of establishing a UDP socket communication on the server side are as follows: \n \n Create a socket with the socket() function; \n Bind the socket to an address using the bind() function; \n Send and receive data by means of recvfrom() and sendto().","UDP client-server. \n \n \nIn this section, we will describe the two new functions recvfrom() and sendto(). \n \nThe recvfrom() Function \n \nThis function is similar to the read() function, but three additional arguments are required. \nThe recvfrom() function is defined as follows: \n \n#include <sys/socket.h> \n \nssize_t recvfrom(int sockfd, void* buff, size_t nbytes, \nint flags, struct sockaddr* from, \nsocklen_t *addrlen);","The first three arguments sockfd, buff, and nbytes, are identical to the first three arguments \nof read and write. sockfd is the socket descriptor, buff is the pointer    to    read    into, \nand nbytes is number of bytes to read. In our examples we will set all the values of \nthe flags argument to 0. The recvfrom function fills in the socket address structure pointed to \nby from with  the  protocol address  of  who  sent  the  datagram.  The  number  of  bytes  stored  in  the","socket address structure is returned in the integer pointed by addrlen. \n \nThe function returns the number of bytes read if it succeeds, -1 on error. \n \nThe sendto() Function \n \nThis function is similar to the send() function, but three additional arguments are required. \nThe sendto() function is defined as follows: \n \n#include <sys/socket.h> \nssize_t sendto(int sockfd, const void *buff, size_t nbytes, \nint flags, const struct sockaddr *to, \nsocklen_t addrlen);","int flags, const struct sockaddr *to, \nsocklen_t addrlen); \n \nThe first three arguments sockfd, buff, and nbytes, are identical to the first three arguments \nof recv. sockfd is the socket descriptor, buff is the pointer to write from, and nbytes is \nnumber of bytes to write. In our examples we will set all the values of the flags argument to 0. \nThe to argument is a socket address structure containing the protocol address (e.g., IP address and","port number) of where the data is sent. addlen specified the size of this socket. \n \nThe function returns the number of bytes written if it succeeds, -1 on error. \n \nConcurrent Servers \n \nThere are two main classes of servers, iterative and concurrent. An iterative server iterates through \neach client, handling it one at a time. A concurrent server handles multiple clients at the same time.","The  simplest  technique for  a  concurrent  server  is  to  call  the fork function,  creating  one  child \nprocess for each client. An alternative technique is to use threads instead (i.e., light-weight \nprocesses). We do not consider this kind of servers in this course. \n \nThe fork() function \n \nThe fork() function is the only way in Unix to create a new process. It is defined as follows: \n \n#include <unist.h> \npid_t fork(void);","The function returns 0 if in child and the process ID of the child in parent; otherwise, -1 on error. \n \nIn fact, the function fork() is called once but returns twice. It returns once in the calling process \n(called the parent) with the process ID of the newly created process (its child). It also returns in the \nchild, with a return value of 0. The return value tells whether the current process is the parent or the \nchild. \n \nExample \n \nA typical concurrent server has the following structure:","child. \n \nExample \n \nA typical concurrent server has the following structure: \n \n \n \npid_t pid; \nint listenfd, connfd; \nlistenfd = socket(...); \n/***fill the socket address with server’s well known port***/ \nbind(listenfd, ...); \nlisten(listenfd, ...); \n \nfor ( ; ; ) { \n \nconnfd = accept(listenfd, ...); /* blocking call */ \nif ( (pid = fork()) == 0 ) { \nclose(listenfd); /* child closes listening socket */ \n \n/***process the request doing something using connfd ***/ \n/* ................. */","/***process the request doing something using connfd ***/ \n/* ................. */ \n \nclose(connfd); \nexit(0); /* child terminates \n} \nclose(connfd); /*parent closes connected socket*/ \n} \n} \n \nWhen  a  connection is  established, accept returns,  the  server  calls fork,  and  the  child  process \nservices the client (on the connected socket connfd). The parent process waits for another","services the client (on the connected socket connfd). The parent process waits for another \nconnection  (on  the  listening  socket listenfd.  The  parent  closes  the  connected  socket  since  the \nchild handles the new client. The interactions among client and server are presented in Figure .","Example of interaction among a client and a concurrent server.","TCP Client/Server Examples \n \nWe now present a complete example of the implementation of a TCP based echo server to \nsummarize the concepts presented above. We present an iterative and a concurrent implementation \nof the server. \n \nechoClient.c source: \n \nTCP Echo Client \n \n \n \n#include <stdlib.h> \n#include <stdio.h> \n#include <sys/types.h> \n#include <sys/socket.h> \n#include <netinet/in.h> \n#include <string.h> \n \n#define MAXLINE 4096 /*max text line length*/ \n#define SERV_PORT 3000 /*port*/","#define MAXLINE 4096 /*max text line length*/ \n#define SERV_PORT 3000 /*port*/ \n \nint \nmain(int argc, char **argv) \n{ \nint sockfd; \nstruct sockaddr_in servaddr; \nchar sendline[MAXLINE], recvline[MAXLINE]; \n \n//basic check of the arguments \n//additional checks can be inserted \nif (argc !=2) { \nperror(\"Usage: TCPClient <IP address of the server\"); \nexit(1); \n} \n \n//Create a socket for the client \n//If sockfd<0 there was an error in the creation of the socket","//Create a socket for the client \n//If sockfd<0 there was an error in the creation of the socket \nif ((sockfd = socket (AF_INET, SOCK_STREAM, 0)) <0) { \nperror(\"Problem in creating the socket\"); \nexit(2); \n} \n \n//Creation of the socket \nmemset(&servaddr, 0, sizeof(servaddr)); \nservaddr.sin_family = AF_INET; \nservaddr.sin_addr.s_addr= inet_addr(argv[1]);","servaddr.sin_port = htons(SERV_PORT); //convert to big- \nendian order \n \n//Connection of the client to the socket \nif (connect(sockfd, (struct sockaddr *) &servaddr, sizeof(servadd \nr))<0) { \nperror(\"Problem in connecting to the server\"); \nexit(3); \n} \n \nwhile (fgets(sendline, MAXLINE, stdin) != NULL) { \nsend(sockfd, sendline, strlen(sendline), 0); \nif (recv(sockfd, recvline, MAXLINE,0) == 0){ \n//error: server terminated prematurely \nperror(\"The server terminated prematurely\"); \nexit(4); \n}","//error: server terminated prematurely \nperror(\"The server terminated prematurely\"); \nexit(4); \n} \nprintf(\"%s\", \"String received from the server: \"); \nfputs(recvline, stdout); \n} \n \nexit(0); \n} \n \nechoServer.c source: \n \nTCP Iterative Server \n \n \n \n#include <stdlib.h> \n#include <stdio.h> \n#include <sys/types.h> \n#include <sys/socket.h> \n#include <netinet/in.h> \n#include <string.h> \n \n#define MAXLINE 4096 /*max text line length*/ \n#define SERV_PORT 3000 /*port*/","#define MAXLINE 4096 /*max text line length*/ \n#define SERV_PORT 3000 /*port*/ \n#define LISTENQ 8 /*maximum number of client connections */ \n \nint main (int argc, char **argv) \n{ \nint listenfd, connfd, n; \nsocklen_t clilen;","char buf[MAXLINE]; \nstruct sockaddr_in cliaddr, servaddr; \n \n//creation of the socket \nlistenfd = socket (AF_INET, SOCK_STREAM, 0); \n \n//preparation of the socket address \nservaddr.sin_family = AF_INET; \nservaddr.sin_addr.s_addr = htonl(INADDR_ANY); \nservaddr.sin_port = htons(SERV_PORT); \n \nbind (listenfd, (struct sockaddr *) &servaddr, sizeof(servaddr)); \nlisten (listenfd, LISTENQ); \nprintf(\"%s\\n\",\"Server running...waiting for connections.\"); \nfor ( ; ; ) { \nclilen = sizeof(cliaddr);","for ( ; ; ) { \nclilen = sizeof(cliaddr); \nconnfd = accept (listenfd, (struct sockaddr *) &cliaddr, &clilen \n); \nprintf(\"%s\\n\",\"Received request...\"); \n \nwhile ( (n = recv(connfd, buf, MAXLINE,0)) > 0) { \nprintf(\"%s\",\"String received from and resent to the client:\"); \nputs(buf); \nsend(connfd, buf, n, 0); \n} \n \nif (n < 0) { \nperror(\"Read error\"); \nexit(1); \n} \nclose(connfd); \n \n} \n//close listening socket \nclose (listenfd); \n}","conEchoServer.c source: \n \nTCP Concurrent Echo Server \n \n \n \n#include <stdlib.h> \n#include <stdio.h> \n#include <sys/types.h> \n#include <sys/socket.h> \n#include <netinet/in.h> \n#include <string.h> \n \n#define MAXLINE 4096 /*max text line length*/ \n#define SERV_PORT 3000 /*port*/ \n#define LISTENQ 8 /*maximum number of client connections*/ \n \nint main (int argc, char **argv) \n{ \nint listenfd, connfd, n; \npid_t childpid; \nsocklen_t clilen; \nchar buf[MAXLINE]; \nstruct sockaddr_in cliaddr, servaddr;","pid_t childpid; \nsocklen_t clilen; \nchar buf[MAXLINE]; \nstruct sockaddr_in cliaddr, servaddr; \n \n//Create a socket for the soclet \n//If sockfd<0 there was an error in the creation of the socket \nif ((listenfd = socket (AF_INET, SOCK_STREAM, 0)) <0) { \nperror(\"Problem in creating the socket\"); \nexit(2); \n} \n \n \n//preparation of the socket address \nservaddr.sin_family = AF_INET; \nservaddr.sin_addr.s_addr = htonl(INADDR_ANY); \nservaddr.sin_port = htons(SERV_PORT); \n \n//bind the socket","servaddr.sin_port = htons(SERV_PORT); \n \n//bind the socket \nbind (listenfd, (struct sockaddr *) &servaddr, sizeof(servaddr)); \n \n//listen to the socket by creating a connection queue, then wait \nfor clients \nlisten (listenfd, LISTENQ); \n \nprintf(\"%s\\n\",\"Server running...waiting for connections.\");","for ( ; ; ) { \n \nclilen = sizeof(cliaddr); \n//accept a connection \nconnfd = accept (listenfd, (struct sockaddr *) &cliaddr, &clilen \n); \n \nprintf(\"%s\\n\",\"Received request...\"); \n \nif ((childpid = fork ()) == 0) {//if it’s 0, it’s child process \n \nprintf (\"%s\\n\",\"Child created for dealing with client requests\") \n; \n \n//close listening socket \nclose (listenfd); \n \nwhile ( (n = recv(connfd, buf, MAXLINE,0)) > 0) { \nprintf(\"%s\",\"String received from and resent to the client:\"); \nputs(buf);","printf(\"%s\",\"String received from and resent to the client:\"); \nputs(buf); \nsend(connfd, buf, n, 0); \n} \n \nif (n < 0) \nprintf(\"%s\\n\", \"Read error\"); \nexit(0); \n} \n//close socket of the server \nclose(connfd); \n} \n}"]}